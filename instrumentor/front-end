#!/usr/bin/perl -w

use strict;
use File::Basename qw(basename);
use File::Temp qw(tempdir tempfile);
use FileHandle;
use FindBin;


########################################################################


my $transformer = '<transformer>';
my $gcc = '<gcc>';


sub usage () {
    die "usage: $0 $transformer $gcc <gcc-options> ...\n"
}


$transformer = shift || usage;
$gcc = shift || usage;
my @cpp = ($gcc);
my @cc = ($gcc);
my @ld = ($gcc);

my $mode = 'link';
my @source;
my $has_inputs;

my $outfile;
my $verbose;

my @holes;
my $save_temps;

my $root = "$FindBin::Bin/..";


########################################################################


sub push_all (@) {
    push @cpp, @_;
    push @cc, @_;
    push @ld, @_;
}


sub handle_1 ($) {
    push_all @_, shift @ARGV;
}


sub handle_c ($) {
    push @cc, @_;
    $mode = 'compile';
}


sub handle_cpp_1 ($) {
    push @cpp, @_, shift @ARGV;
}


sub handle_E ($) {
    push @cpp, @_;
    $mode = 'preprocess';
}


sub handle_o ($) {
    $outfile = shift @ARGV;
}


sub handle_save_temps ($) {
    &push_all;
    $save_temps = 1;
}


sub handle_S ($) {
    &push_all;
    $mode = 'codegen';
}


sub handle_special ($) {
    push @cc, @_;
    $mode = 'special';
}


sub handle_v ($) {
    &push_all;
    $verbose = 1;
}


sub handle_x ($) {
    &push_all;
    my $language = shift @ARGV;
    die "unsupported language option: $language\n"
	unless $language eq 'c';
    push_all $language;
}


my %flag_spec = (
		 # overall options
		 'c' => \&handle_c,
		 'S' => \&handle_S,
		 'o' => \&handle_o,
		 'v' => \&handle_v,

		 # C dialect options
		 'x' => \&handle_x,

		 # warning options
		 'fsyntax-only' => \&handle_special,

		 # debugging options
		 'save-temps' => \&handle_save_temps,

		 # preprocessor options
		 'include' => \&handle_cpp_1,
		 'imacros' => \&handle_1,
		 'idirafter' => \&handle_1,
		 'iprefix' => \&handle_1,
		 'iwithprefix' => \&handle_1,
		 'iwithprefixbefore' => \&handle_1,
		 'isystem' => \&handle_1,
		 'isystem-c++' => \&handle_1,
		 'E' => \&handle_E,
		 'M' => \&handle_E,
		 'MM' => \&handle_E,
		 'MD' => \&handle_E,
		 'MMD' => \&handle_E,

		 # link options
		 'Xlinker' => \&handle_1,
		 'u' => \&handle_1,

		 # directory options
		 'I' => \&handle_1,
		 'L' => \&handle_1,

		 # target options
		 'b' => \&handle_1,
		 'V' => \&handle_1,

		 # submodel options
		 'G' => \&handle_1,
		 );


########################################################################


sub check_system (@) {
    my $error = system @_;

    if ($error == -1) {
	exit 2;
    } elsif ($error) {
	my $result = $error >> 8 || $error & 127 || -1;
	exit $result;
    }
}


sub trace_redirect ($$@) {
    my $handle = shift;
    my $name = shift;
    my $descriptor = fileno $handle;

    warn "@_ >$name\n" if $verbose;
    open OLDOUT, ">&STDOUT" or die "cannot preserve stdout: $!\n";
    open STDOUT, ">&$descriptor" or die "cannot redirect stdout: $!\n";
    &check_system;
    open STDOUT, ">&OLDOUT" or die "cannot restore stdout: $!\n";
    fileno OLDOUT; 		# suppress a warning
}


sub trace_system (@) {
    warn "@_\n" if $verbose;
    &check_system;
}


sub push_library ($$) {
    my ($dir, $lib) = @_;
    push @ld, "-Wl,-rpath,$dir", "-L$dir", "-l$lib";
}


sub temp ($$) {
    my ($suggested, $suffix) = @_;
    if ($save_temps) {
	my $name = "$suggested.$suffix";
	return (new FileHandle($name, 'w'), $name);
    } else {
	return tempfile(SUFFIX => ".$suffix", UNLINK => 1);
    }
}


########################################################################


push @ARGV, '-include', "$root/libcountdown/countdown.h";
push @ARGV, '-include', "$root/liblog/log.h";


while ($_ = shift) {
    if (/^-(.*)/) {
	
	my $key = $1;
	my $handler = $flag_spec{$key};

	if ($handler) {
	    &{$handler}($_);
	    next;
	}

	# debugging options
	if ($key =~ /^print-/) {
	    handle_special $_;
	    next;
	}

	# link options
	if ($key =~ /^l/) {
	    push @ld, $_;
	    $has_inputs = 1;
	    next;
	}
	if ($key =~ /^Wl,/) {
	    push @ld, $_;
	    next;
	}

	# everything else
	push_all $_;

    } else {
	$has_inputs = 1;

	if (/(.*)\.c$/) {
	    push @source, $_;
	    push @ld, undef;
	    push @holes, \$ld[$#ld];
	    
	} else {
	    push @ld, $_;
	}
    }
}


$mode = 'special' unless $has_inputs;

if ($mode eq 'special') {
    trace_system @cc;

} elsif ($mode eq 'preprocess') {
    foreach (@source) {
	my @out = ('-o', $outfile) if $outfile;
	trace_system @cpp, @out, $_;
    }
    
} else {

    foreach (@source) {
	my $base = basename $_, '.c';
	my ($i_handle, $i_name) = temp $base, 'i';
	trace_redirect $i_handle, $i_name, @cpp, '-E', $_;
	
	my ($c_handle, $c_name) = temp "$base.inst", 'c';
	trace_redirect $c_handle, $c_name, $transformer, $i_name;
	
	if ($mode eq 'compile') {
	    my $o = $outfile || "$base.o";
	    trace_system @cc, '-o', $o, $c_name;
	} elsif ($mode eq 'codegen') {
	    my $o = $outfile || "$base.s";
	    trace_system @cc, '-o', $o, $c_name;
	} else {
	    ${shift @holes} = $c_name;
	}
    }

    if ($mode eq 'link') {
	my @out = ('-o', $outfile) if $outfile;
	push_library "$root/libcountdown", 'countdown';
	push_library "$root/liblog", 'log';
	trace_system @ld, @out;
    }
}
