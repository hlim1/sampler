-*- outline -*-

* Introduction

\item Based on the current state of automatic analysis, clients can be
instructed to focus attention in data gathering on different aspects
of the software.  For example, if there appears to be a problem with a
particular function $f$, we may wish clients to disproportionately
report information about $f$ for a period of time, to speed up the
process of gathering enough data for analysis.

* Applications and Experiments
** Bug Isolation Using Predicate Elimination
*** Elimination Strategies

These heuristics preclude us from identifying certain types of errors,
such as forgotten initialization bugs.  If a program only crashes when
it fails to run some initialization code, \elim{lack of failing
coverage} will observe that the initialization code is not used on
crashing runs, and therefore conclude that this cannot be the cause of
the bug.  Any attempt to identify crashes caused by code that did
\emph{not} run is just as likely to seize upon the \texttt{return}
statement at the end of \texttt{main()}: this is a statement that is
consistently reached by successful runs but not reached by runs that
crash.  Yet reporting that the program crashed because it failed to
return from \texttt{main()} is hardly useful.  A more refined
treatment of code with differing roles may be required in order to
capture this class of bugs.

* Privacy and Security

Furthermore, while one can visually scan a Mozilla crash report for
incriminating strings, users cannot be expected to make informed
privacy judgments about a predicate counters report that reveals that
\texttt{indx} was found to be greater than \texttt{a\_count} 5280
times.

..., and the information which is revealed will generally be so
randomly scattered as to make coherent reassembly of a compound value,
such as a password string, infeasible.

A greater challenge is assuring the correctness of these (or any)
type-based approaches in the presence of memory safety bugs, but the
\CCured project has shown that this too is possible.
