<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                         "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
                         [<!ENTITY % config SYSTEM "config.xml"> %config;]>
<article>
  <articleinfo>
    <title>Guide to the Bug Isolation Sampler</title>
    <author>
      <firstname>Ben</firstname>
      <surname>Liblit</surname>
    </author>
  </articleinfo>
  <section>
    <title>Using the Instrumenting Compiler</title>
    <section>
      <title>Getting and Installing the Sampler</title>

      <remark>Not yet written.  Tools are currently built and
      installed on <literal>ash.cs.berkeley.edu</literal> under
      <filename class="directory">&samplerdir;</filename>.</remark>
    </section>
    
    <section>
      <title>Building Instrumented Executables</title>

      <para>The instrumentor provides a driver script that acts as a
      transparent wrapper around <application>GCC</application>.  It is run as
      follows:</para>

      <cmdsynopsis>
	<command>&samplerdir;/instrumentor/driver/main</command>
	<arg choice="req"><replaceable>scheme</replaceable></arg>
	<sbr/>
	<group choice="req" rep="repeat">
	  <arg choice="plain"><replaceable>source file</replaceable></arg>
	  <arg choice="plain"><replaceable>compiler option</replaceable></arg>
	  <arg choice="plain"><replaceable>instrumentor option</replaceable></arg>
	</group>
      </cmdsynopsis>

      <para>The mandatory <replaceable
      class="parameter">scheme</replaceable> argument selects an
      instrumentation scheme, and must appear as the first argument to
      the driver.  The following instrumentation schemes are currently
      available:</para>

      <variablelist>
	<title>Instrumentation schemes</title>
	<varlistentry>
	  <term><option>branches</option></term>
	  <listitem>
	    <para>For each conditional (branch), count how many times
            the branch predicate is false or true.  This includes
            <literal>if</literal> statements as well as branches that
            are implicit in looping control structures and certain
            operators (<literal>&amp;&amp;</literal>,
            <literal>||</literal>, <literal>?:</literal>).  Each
            branch induces one instrumentation point with a pair of counters.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>returns</option></term>
	  <listitem>
	    <para>At each scalar-returning call site, count how many
	    times the called function returned a negative, zero, or
	    positive value.  Each such call induces one
	    instrumentation point with a triple of counters.  This is
	    the scheme used for the <application>ccrypt</application>
	    experiment in our PLDI paper.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>scalar-pairs</option></term>
	  <listitem>
	    <para>At each direct scalar assignment, count how many
	    times the assigned value value is less than, equal to, or
	    greater than each other same-typed in-scope variable.
	    Each such comparable variable at each such assignment
	    induces one instrumentation point with a triple of
	    counters.  This is the scheme used for the
	    <application>bc</application> experiment in our PLDI
	    paper.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>decure</option></term>
	  <listitem>
	    <para>Instrument the application using
	    <application>CCured</application>.  Each
	    <application>CCured</application> runtime memory check
	    induces one instrumentation point.  There are no counters;
	    checks that are not skipped due to random sampling are
	    performed in the standard manner, and will abort the
	    program if they fail.  This is the scheme used for the
	    <application>CCured</application> experiment in our PLDI
	    paper.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Remaining arguments can be source files to compile,
      standard <application>GCC</application> command line flags, or
      special instrumentor flags that fine tune the instrumentation
      process.  In the special case of the
      <option>decure</option> scheme, all standard
      <application>CCured</application> command line flags are
      accepted as well.</para>

      <para>Recognized instrumentor flags are as follows:</para>

      <variablelist>
	<title>Instrumentor flags</title>
	<varlistentry>
	  <term><option>--sample</option></term>
	  <term><option>--no-sample</option></term>
	  <listitem>
	    <para>Enable or disable sampling of instrumentation
	    points.  If sampling is disabled, instrumentation points
	    are run unconditionally.  Default is to sample.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>--include-function
	  {<function><replaceable>function</replaceable></function>|<literal>*</literal>}</option></term>
	  <term><option>--exclude-function
	  {<function><replaceable>function</replaceable></function>|<literal>*</literal>}</option></term>
	  <listitem>
	    <para>Function filtering.  Each of these flags takes one
	    mandatory argument which can be the name of a function or
	    the special wildcard <literal>*</literal> which names
	    every function.  These flags can be given multiple times,
	    creating an ordered include/exclude list.  Each function
	    that might be instrumented is checked against this list.
	    The first match determines whether that function should be
	    included or excluded from instrumentation.</para>

	    <para>These flags are useful for filtering out boring
	    functions:</para>

	    <informalexample>
	      <para><userinput>&hellip; <option>--exclude-function
	      <function>boringFunction</function></option>
	      &hellip;</userinput></para>
	    </informalexample>

	    <para>They can also be used to create executables with
	    just a few selected functions instrumented:</para>

	    <informalexample>
	      <para><userinput>&hellip; <option>--include-function
	      <function>boringFunction</function></option>
	      <option>--exclude-function <literal>*</literal></option>
	      &hellip;</userinput></para>
	    </informalexample>

	    <para>Default is to include all functions, as though
	    <option>--include-function <literal>*</literal></option>
	    were implicitly the last flag given.</para>

	    <important>
	      <para>If you use the wildcard, remember to protect it
	      from expansion by the shell such as by quoting it as
	      <userinput>'*'</userinput> or
	      <userinput>"*"</userinput>.</para>
	    </important>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>--include-file
	  {<filename><replaceable>filename</replaceable></filename>|<literal>*</literal>}</option></term>
	  <term><option>--exclude-file
	  {<filename><replaceable>filename</replaceable></filename>|<literal>*</literal>}</option></term>
	  <listitem>
	    <para>File filtering.  Each of these flags takes one
	    mandatory argument which can be the name of a source file
	    or the special wildcard <literal>*</literal> which names
	    every file.  These flags can be given multiple times,
	    creating an ordered include/exclude list.  Each potential
	    instrumentation point is checked against this list, using
	    the name of the source file containing that point.  The
	    first match determines whether that instrumentation point
	    should be retained or discarded.</para>

	    <para>Included and excluded file names are checked against
	    names as seen by the compiler.  These will tend to be
	    simple file names for source files given on the command
	    line, but may be relative or absolute path names for
	    header files pulled in by the preprocessor.  File names
	    must match exactly to be considered.  In some cases it may
	    be necessary to examine the preprocessor output to learn
	    what file name the compiler is seeing for a given fragment
	    of code.</para>

	    <para>Note that checks are done using the name of the file
            actually containing the potential instrumentation point.
            If source file <filename>code.c</filename> brings in
            header file <filename
            class="headerfile">header.h</filename>, and that header
            contains a complete function definition, then
            instrumentation points in that function body will be
            included or excluded based on <filename
            class="headerfile">header.h</filename> as their file name,
            not <filename>code.c</filename>.</para>

            <para>Also note that this check is performed at each
            individual instrumentation point.  If a single function
            contains code from multiple source files, this filter can
            include some instrumentation points while excluding
            others.  This can happen, for example, in
            <application>Bison</application> parsers and
            <application>Flex</application> lexers which mix
            user-specified actions with fixed boilerplate.  One can
            instrument the actions while excluding the
            boilerplate:</para>

	    <informalexample>
	      <para><userinput>&hellip; <option>--exclude-file
	      <filename>/usr/gnu/share/bison.simple</filename></option>
	      <option>--exclude-file
	      <filename>lex.yy.c</filename></option>
	      &hellip;</userinput></para>
	    </informalexample>

	    <para>Default is to include instrumentation points from
	    all files, as though <option>--include-file
	    <literal>*</literal></option> were implicitly the last
	    flag given.</para>

	    <important>
	      <para>If you use the wildcard, remember to protect it
	      from expansion by the shell such as by quoting it as
	      <userinput>'*'</userinput> or
	      <userinput>"*"</userinput>.</para>
	    </important>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>--acyclic</option></term>
	  <term><option>--cyclic</option></term>
	  <listitem>
	    <para>Countdown management.  The acyclic countdown style
	    generates countdowns as needed at runtime within the
	    program itself.  The cyclic style uses a pre-generated
	    bank of &cycliccount; countdowns which much be generated
	    and stored before the instrumented program is launched.
	    See <xref linkend="envars" /> for how this choice affects
	    which environment variables should be set at run time.
	    Default is acyclic.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>--show-stats</option></term>
	  <term><option>--no-show-stats</option></term>
	  <listitem>
	    <para>Static metrics.  Used for data collection when
	    writing papers.  Default is silent operation.  Safe to
	    ignore.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>--specialize-empty-regions</option></term>
	  <term><option>--no-specialize-empty-regions</option></term>
	  <term><option>--specialize-singleton-regions</option></term>
	  <term><option>--no-specialize-singleton-regions</option></term>
	  <listitem>
	    <para>Region specialization optimizations.  Default is to
	    perform all specializations.  Safe to ignore.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>--use-points-to</option></term>
	  <term><option>--no-use-points-to</option></term>
	  <listitem>
	    <para>Experimental optimizations for indirect function
	    calls.  Defaults to disabled.  Not yet trusted as correct,
	    and should not be used.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>Running Instrumented Programs</title>
    <section id="launchers">
      <title>High-Level Control Via Launchers</title>

      <remark>We have created wrapper tools which launch instrumented
      applications, collect sample reports, and upload them to a
      central collection sever based on some simple configuration
      files.  Documentation for these tools is not yet available, but
      should be coming along soon.  Most readers should wait for that
      documentation rather than fretting over the environment
      variables described in <link linkend="envars">the next
      section</link>.</remark>

      <remark>The launchers currently assume that the program was
      compiled using <option>--acyclic</option>.  We should either
      remove that restriction or document it clearly here.</remark>
    </section>

    <section id="envars">
      <title>Low-Level Control Via Environment Variables</title>

      <para>The instrumented executable uses a set of environment
      variables to control sampling and post-execution reporting.
      Most applications should not need to deal with these directly,
      and can instead use a launcher as described in <link
      linkend="launchers">the previous section</link>.</para>

      <para>The following environment variables influence the behavior
      of an instrumented executable:</para>

      <variablelist>
	<varlistentry>
	  <term><envar>$SAMPLER_EVENT_COUNTDOWNS</envar></term>
	  <listitem>
	    <para>Used when the executable was built with
	    <option>--cyclic</option>.  Set this to the name of a file
	    containing pre-generated random countdowns.  See <xref
	    linkend="precompute" /> for information on a tool for
	    building these countdown files.</para>

	    <para>Not used when either <option>--acyclic</option> or
	    <option>--no-sample</option> was given at compile
	    time.</para>

	    <para>If not set, countdowns are always initialized to
	    <symbol>UINT_MAX</symbol>, effectively disabling
	    sampling.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><envar>$SAMPLER_SPARSITY</envar></term>
	  <listitem>
	    <para>Used when the executable was built with
	    <option>--acyclic</option>.  Set this to an integer which
	    will be used as the sampling sparsity.  A sparsity of
	    <userinput>1000</userinput>, for example, will sample
	    approximately one in instrumentation point per thousand
	    opportunities.</para>

	    <para>Not used when either <option>--cyclic</option> or
	    <option>--no-sample</option> was given at compile
	    time.</para>

	    <para>If not set, countdowns are always initialized to
	    <symbol>UINT_MAX</symbol>, effectively disabling
	    sampling.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><envar>$SAMPLER_SEED</envar></term>
	  <listitem>
	    <para>Used when the executable was built with
	    <option>--acyclic</option>.  Seeds the random number
	    generator.</para>

	    <para>Not used when either <option>--cyclic</option> or
	    <option>--no-sample</option> was given at compile
	    time.</para>

	    <para>If not set, defaults to a fixed value (zero).
	    Therefore, one always set this environment variable to
	    some value, preferably selected at random.  Otherwise,
	    every run will use the same sequence of countdowns.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><envar>$SAMPLER_FILE</envar></term>
	  <listitem>
	    <para>If set, names a file into which the sampler report
	    will be written at program exit time.  Any occurrence of
	    the substring <quote><literal>$$</literal></quote> will be
	    replaced by the program's own process ID. This simplifies
	    data collection from multiple invocations or from
	    instrumented applications which spawn off multiple copies
	    of themselves.</para>

	    <para>If not set, no post-execution report will be
	    produced.  This does not disable sampling while the
	    program runs, but it does mean that the results of the
	    sampling will not be recorded anywhere once the program
	    exits.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><envar>$SAMPLER_DEBUGGER</envar></term>
	  <listitem>
	    <para>If set, names a program which will be run to print
	    out additional debugging information when the instrumented
	    program fails due to a fatal signal.  The debugger program
	    will receive the instrumented program's process ID as its
	    only argument, and should print its information to
	    standard out, where it will be collected and appended to
	    <envar>$SAMPLER_FILE</envar>.</para>

	    <para>On Linux workstations equipped with
	    <application>GDB</application>, a suitable value for this
	    environment variable is
	    <filename>&samplerdir;/launcher/print-debug-info</filename>.</para>

	    <para>If not set, no additional debug report will be
	    appended to <envar>$SAMPLER_FILE</envar>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </section>

    <section>
      <title>Supporting Tools</title>
      <section id="precompute">
	<title><command>precompute</command></title>

	<para><filename>&samplerdir;/libcountdown/precompute</filename>
	is a tool for producing pre-generated countdowns.  This should
	be used in conjunction with the <option>--cyclic</option> flag
	and the <envar>$SAMPLER_EVENT_COUNTDOWNS</envar> environment
	variable.  Before starting the instrumented program:</para>

	<procedure>
	  <step>
	    <para>Set <envar>SAMPLER_SEED</envar> to some random seed
	    integer.</para>
	  </step>
	  
	  <step>
	    <para>Run <userinput>precompute
	    <filename><replaceable>outfile</replaceable></filename></userinput>
	    to generate and store &cycliccount; random countdowns in
	    <filename><replaceable>outfile</replaceable></filename>.</para>
	  </step>

	  <step>
	    <para>Set <envar>$SAMPLER_EVENT_COUNTDOWNS</envar> to name
	    this same file when running the instrumented
	    program.</para>
	  </step>
	</procedure>
      </section>
    </section>
  </section>

  <section>
    <title>Managing a Report Collection Server</title>

    <remark>Not yet written.  Will eventually document setting up the
    report collection script as a CGI service running under the
    <application>Apache</application> web server.</remark>
  </section>
</article>
