#!/usr/bin/perl -w

use strict;
use Config;
use FileHandle;
use File::Spec;


########################################################################


my @names = split ' ', $Config{sig_name};
my @numbers = split ' ', $Config{sig_num};
my %signals = map { $_ => $names[$_] } @numbers;
undef @names;
undef @numbers;


########################################################################


@ARGV == 5 or die "usage: $0 <input> <seed> <trace> <signal> <command>\n";
my ($command, $input, $seed, $trace, $signal) = @ARGV;


########################################################################


print "$input: ";

my $pid = fork;
die "cannot fork: $pid/$!\n" unless defined $pid;

if ($pid == 0) {
    $command = File::Spec->rel2abs($command);
    $input = File::Spec->rel2abs($input);
    $trace = File::Spec->rel2abs($trace);
    chdir '/';
    -x $command or die "cannot execute $command: $!\n";
    open STDIN, "<$input" or die "cannot read $input: $!\n";
    open STDOUT, '>/dev/null' or die "cannot write /dev/null: $!\n";
    open STDERR, '>/dev/null' or die "cannot write /dev/null: $!\n";
    %ENV = (SAMPLER_FILE => $trace,
	    SAMPLER_SPARSITY => 4000,
	    GSL_RNG_SEED => $seed);
    exec $command or die "cannot exec $command: $!\n";
} else {
    my $reap = waitpid $pid, 0;
    die "cannot waitpid: $!\n" unless $reap == $pid;
    my $signum = $? & 127;
    print(($signum ? "fail ($signals{$signum})" : "pass"), "\n");
    my $sigfile = new FileHandle $signal, 'w';
    $sigfile->print("$signum\n");
}
