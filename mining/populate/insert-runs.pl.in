#!@PERL@ -w

use strict;
use 5.008;			# for safe pipe opens using list form of open

use DBI;
use File::Basename;
use File::stat;
use File::Temp qw(tempfile);
use FileHandle;
use POSIX qw(strftime);

use Common;
use Upload;

my $dry_run = (@ARGV && $ARGV[0] eq '--dry-run') ? shift : undef;

my $dbh = Common::connect;


########################################################################
#
#  get the list of already-known sample reports
#


sub get_known ($) {
    my ($dbh) = @_;
    my $column = $dbh->selectcol_arrayref('SELECT run_id FROM run UNION SELECT run_id FROM run_suppress ORDER BY run_id');

    print scalar @{$column}, " runs already known or suppressed\n";

    my %known;
    $known{$_} = 1 foreach @{$column};
    return %known;
}


my %known = get_known $dbh;


########################################################################
#
#  get the list of suppressed builds
#


sub get_suppressed ($) {
    my ($dbh) = @_;
    my $rows = $dbh->selectall_arrayref(q{
	SELECT application_name, application_version, application_release, build_distribution
	    FROM build
	    NATURAL JOIN build_suppress});

    print scalar @{$rows}, " builds suppressed\n";

    my %suppressed;
    foreach my $row (@{$rows}) {
	my $app_id = join("\t", @{$row});
	$suppressed{$app_id} = 1;
    }

    return %suppressed;
}


my %suppressed = get_suppressed $dbh;


########################################################################
#
#  simple helper functions
#


my @slot = ('HTTP_SAMPLER_APPLICATION_NAME',
	    'HTTP_SAMPLER_APPLICATION_VERSION',
	    'HTTP_SAMPLER_APPLICATION_RELEASE',
	    'HTTP_SAMPLER_BUILD_DISTRIBUTION',
	    'HTTP_SAMPLER_VERSION',
	    'HTTP_SAMPLER_SPARSITY',
	    'HTTP_SAMPLER_EXIT_SIGNAL',
	    'HTTP_SAMPLER_EXIT_STATUS',
	    'DATE');


sub guess_distro (\%) {
    my $environment = shift;
    my $instrumentor = $environment->{HTTP_SAMPLER_INSTRUMENTOR_VERSION};
    return 'redhat-9-i386' unless defined $instrumentor;
    return 'fedora-1-i386' if $instrumentor eq '0.9.1';
    return 'redhat-9-i386';
}


sub read_environment ($\%) {
    my ($dir, $known) = @_;

    my $filename = "$dir/environment";
    my $file = new FileHandle($filename) or die "cannot read $filename: $!";
    my %environment;

    while (my $line = <$file>) {
	$line =~ /^([^	]+)	(.*)$/ or die;
	$environment{$1} = $2;
    }

    $environment{HTTP_SAMPLER_BUILD_DISTRIBUTION} = guess_distro %environment
	unless defined $environment{HTTP_SAMPLER_BUILD_DISTRIBUTION};

    $environment{HTTP_SAMPLER_BUILD_DISTRIBUTION} = 'fedora-4-i386'
	if $environment{HTTP_SAMPLER_BUILD_DISTRIBUTION} eq 'fedora-4-noarch';

    $environment{HTTP_SAMPLER_VERSION} = $environment{HTTP_SAMPLER_INSTRUMENTOR_VERSION}
	unless defined $environment{HTTP_SAMPLER_VERSION};

    $environment{HTTP_SAMPLER_VERSION} = $environment{HTTP_SAMPLER_INSTRUMENTATION_VERSION}
	unless defined $environment{HTTP_SAMPLER_VERSION};

    unless (defined $environment{DATE}) {
	my $stat = stat($filename) or die;
	$environment{DATE} = strftime('%F %T', gmtime $stat->mtime);
    }

    foreach (@slot) {
	die "$filename: $_ is undefined\n"
	    unless defined $environment{$_};
    }

    my $app_id = join("\t", @environment{@slot[0 .. 3]});
    return undef if $suppressed{$app_id};
    return undef if $environment{HTTP_SAMPLER_APPLICATION_NAME} eq 'gnumeric';

    return \%environment;
}


sub environment_fields (\%) {
    my ($environment) = @_;
    my @result;

    foreach (@slot) {
	exists $environment->{$_} or die "missing environment field: $_";
	push @result, $environment->{$_};
    }

    return @result;
}


########################################################################
#
#  prepare receiving area for bulk upload
#


$dbh->do(q{
    CREATE TEMPORARY TABLE upload_run
	(run_id VARCHAR(24) NOT NULL,
	 application_name VARCHAR(50) NOT NULL,
	 application_version VARCHAR(50) NOT NULL,
	 application_release VARCHAR(50) NOT NULL,
	 build_distribution VARCHAR(50) NOT NULL,
	 version VARCHAR(255),
	 sparsity INTEGER NOT NULL CHECK (sparsity > 0),
	 exit_signal SMALLINT NOT NULL CHECK (exit_signal >= 0),
	 exit_status SMALLINT NOT NULL CHECK (exit_status >= 0),
	 CHECK (exit_status = 0 OR exit_signal = 0),
	 date TIMESTAMP NOT NULL)
    }) or die;


########################################################################
#
#  insert any new reports
#


my $upload_run = new Upload($dbh, 'upload_run');

sub insert_run ($) {
    my $dir = dirname shift;
    my $run_id = basename $dir;

    # skip already-known reports
    return if exists $known{$run_id};
    $known{$run_id} = 1;

    # load environment, and skip reports from bad builds
    my $environment = read_environment $dir, %known;
    return unless defined $environment;

    # new report of good build, so add to upload
    print "new: $dir\n";
    my @environment = environment_fields %{$environment};
    $upload_run->row($run_id, @environment);
}


if (@ARGV) {
    insert_run $_ foreach @ARGV;
} else {
    while (local $_ = <STDIN>) {
	chomp;
	insert_run $_;
    }
}


print $upload_run->count, " new runs:\n";

print "\tupload\n";
$upload_run->done;


########################################################################
#
#  add to existing tables
#


unless ($dry_run) {

    print "\tinsert\n";

    $dbh->do(q{
	INSERT INTO run
	    SELECT
		run_id,
		build_id,
		version,
		sparsity,
		exit_signal,
		exit_status,
		date
	    FROM upload_run
	    NATURAL LEFT JOIN build
	}) or die;
}


########################################################################
#
#  finish up
#


$dbh->commit;
$dbh->disconnect;
