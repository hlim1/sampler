Install something in /usr/share/omf.

Each thread starts its own random sequence of countdowns with the same
initial state used when the application first launched.  An
alternative would be for all threads to share the same random state.
This would require locking: what performance penalty would result?
Would this give us more truly random countdowns?

Document --{no-,}assume-weightless-{libraries,externs} and hook them
up in the Perl driver.

how does launcher propagate SIGINT (^C) down to child?

PairClassifier.visitor does a lot of redundant work to re-scan for
globals from the start of the file for each new instance.  We should
be able to accumulate this incrementally as we go along.

Remember which functions are loopless.  Use this to optimize treatment
of calls to known loopless functions.

instrumentor/logging/loads/tests/multiple is incorrectly printing a
single value multiple times

assume that anything declared in /usr/include/... or
/usr/lib/gcc-lib/... or perhaps a few other places is library code
